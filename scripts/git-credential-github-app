#!/usr/bin/env node
/**
 * git-credential-github-app — Git credential helper for GitHub App tokens
 *
 * Generates just-in-time GitHub App installation tokens. Works as both a
 * standard git credential helper and a standalone token CLI for the gh wrapper.
 *
 * Modes:
 *   git-credential-github-app get          Git credential protocol (stdin/stdout)
 *   git-credential-github-app store        No-op (caching is internal)
 *   git-credential-github-app erase        Clear cached token
 *   git-credential-github-app --token      Output bare token string (for GH_TOKEN)
 *
 * Environment variables (all read at runtime):
 *   GITHUB_APP_ID                  GitHub App ID (required)
 *   GITHUB_APP_INSTALLATION_ID     Installation ID (required)
 *   GITHUB_APP_PRIVATE_KEY         PEM private key content (option A)
 *   GITHUB_APP_PRIVATE_KEY_PATH    Path to PEM file (option B)
 *   GITHUB_APP_PRIVATE_KEY_BASE64  Base64-encoded PEM (option C)
 *   GITHUB_API_URL                 API base URL (default: https://api.github.com)
 *   GITHUB_APP_CACHE_DIR           Cache directory override
 *
 * If the required env vars are missing, the helper outputs nothing and exits 0,
 * allowing git to fall through to the next credential helper in the chain.
 */

const fs = require("node:fs");
const path = require("node:path");
const crypto = require("node:crypto");
const os = require("node:os");
const readline = require("node:readline");

// ============================================================================
// Configuration
// ============================================================================

const GITHUB_API_URL =
  process.env.GITHUB_API_URL || "https://api.github.com";
const CACHE_DIR =
  process.env.GITHUB_APP_CACHE_DIR ||
  path.join(os.homedir(), ".cache", "github-app-credential");
const CACHE_FILE = path.join(CACHE_DIR, "token.json");

// Refresh 5 minutes before the 1-hour expiry
const EXPIRY_BUFFER_MS = 5 * 60 * 1000;

// ============================================================================
// Private key resolution
// ============================================================================

function loadPrivateKey() {
  // Option A: PEM content directly in env var
  if (process.env.GITHUB_APP_PRIVATE_KEY) {
    let key = process.env.GITHUB_APP_PRIVATE_KEY;
    // Handle escaped newlines from some secret managers
    if (key.includes("\\n") && !key.includes("\n")) {
      key = key.replace(/\\n/g, "\n");
    }
    return key;
  }

  // Option B: Path to PEM file
  if (process.env.GITHUB_APP_PRIVATE_KEY_PATH) {
    return fs.readFileSync(process.env.GITHUB_APP_PRIVATE_KEY_PATH, "utf8");
  }

  // Option C: Base64-encoded PEM
  if (process.env.GITHUB_APP_PRIVATE_KEY_BASE64) {
    return Buffer.from(
      process.env.GITHUB_APP_PRIVATE_KEY_BASE64,
      "base64"
    ).toString("utf8");
  }

  return null;
}

// ============================================================================
// JWT generation (RS256, zero dependencies)
// ============================================================================

function base64url(data) {
  const buf = typeof data === "string" ? Buffer.from(data, "utf8") : data;
  return buf
    .toString("base64")
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=/g, "");
}

function generateJWT(appId, privateKeyPem) {
  const key = crypto.createPrivateKey(privateKeyPem);
  const now = Math.floor(Date.now() / 1000);

  const header = base64url(JSON.stringify({ alg: "RS256", typ: "JWT" }));
  const payload = base64url(
    JSON.stringify({
      iat: now - 60, // clock-skew tolerance
      exp: now + 600, // 10-minute max lifetime
      iss: String(appId),
    })
  );

  const signature = crypto.sign(
    "RSA-SHA256",
    Buffer.from(`${header}.${payload}`),
    { key, padding: crypto.constants.RSA_PKCS1_PADDING }
  );

  return `${header}.${payload}.${base64url(signature)}`;
}

// ============================================================================
// Installation token request
// ============================================================================

async function requestInstallationToken(appId, installationId, privateKeyPem) {
  const jwt = generateJWT(appId, privateKeyPem);
  const url = `${GITHUB_API_URL}/app/installations/${installationId}/access_tokens`;

  const res = await fetch(url, {
    method: "POST",
    headers: {
      Accept: "application/vnd.github+json",
      Authorization: `Bearer ${jwt}`,
      "X-GitHub-Api-Version": "2022-11-28",
    },
  });

  if (!res.ok) {
    const body = await res.text();
    throw new Error(`GitHub API ${res.status}: ${body}`);
  }

  const data = await res.json();
  return {
    token: data.token,
    expiresAt: new Date(data.expires_at).getTime(),
  };
}

// ============================================================================
// File-based token cache (0600 perms, atomic writes)
// ============================================================================

function readCache(appId, installationId) {
  try {
    if (!fs.existsSync(CACHE_FILE)) return null;
    const cached = JSON.parse(fs.readFileSync(CACHE_FILE, "utf8"));

    if (
      typeof cached.token !== "string" ||
      typeof cached.expiresAt !== "number"
    ) {
      return null;
    }
    if (
      cached.appId !== appId ||
      cached.installationId !== installationId ||
      cached.apiUrl !== GITHUB_API_URL
    ) {
      return null;
    }
    if (cached.expiresAt - Date.now() <= EXPIRY_BUFFER_MS) {
      return null;
    }
    return cached;
  } catch {
    return null;
  }
}

function writeCache(entry) {
  try {
    fs.mkdirSync(CACHE_DIR, { recursive: true, mode: 0o700 });
    const tmp = `${CACHE_FILE}.${process.pid}.tmp`;
    fs.writeFileSync(tmp, JSON.stringify(entry, null, 2), {
      encoding: "utf8",
      mode: 0o600,
    });
    fs.renameSync(tmp, CACHE_FILE);
    try {
      fs.chmodSync(CACHE_FILE, 0o600);
    } catch {
      /* best-effort on non-POSIX */
    }
  } catch (err) {
    process.stderr.write(
      `git-credential-github-app: cache write failed: ${err.message}\n`
    );
  }
}

function clearCache() {
  try {
    if (fs.existsSync(CACHE_FILE)) fs.unlinkSync(CACHE_FILE);
  } catch {
    /* ignore */
  }
}

// ============================================================================
// Token retrieval (cached or fresh)
// ============================================================================

async function getToken() {
  const appId = process.env.GITHUB_APP_ID;
  const installationId = process.env.GITHUB_APP_INSTALLATION_ID;
  const privateKeyPem = loadPrivateKey();

  // Missing config → return null so git falls through to next helper
  if (!appId || !installationId || !privateKeyPem) {
    return null;
  }

  const cached = readCache(appId, installationId);
  if (cached) return cached;

  const fresh = await requestInstallationToken(
    appId,
    installationId,
    privateKeyPem
  );
  const entry = { ...fresh, appId, installationId, apiUrl: GITHUB_API_URL };
  writeCache(entry);
  return entry;
}

// ============================================================================
// Git credential helper protocol
// ============================================================================

async function parseStdin() {
  const ctx = {};
  const rl = readline.createInterface({
    input: process.stdin,
    terminal: false,
  });
  for await (const line of rl) {
    if (line === "") break;
    const i = line.indexOf("=");
    if (i > 0) ctx[line.slice(0, i)] = line.slice(i + 1);
  }
  return ctx;
}

async function handleGet() {
  const ctx = await parseStdin();

  // Determine expected host from API URL
  const expectedHost =
    GITHUB_API_URL === "https://api.github.com"
      ? "github.com"
      : new URL(GITHUB_API_URL).hostname;

  // Only respond for matching host; output nothing for others
  if (ctx.host && ctx.host !== expectedHost) return;

  const result = await getToken();
  if (!result) return; // No config — silent fallthrough

  const expiryUtc = Math.floor(result.expiresAt / 1000);
  const out = [
    `protocol=${ctx.protocol || "https"}`,
    `host=${ctx.host || expectedHost}`,
    ...(ctx.path ? [`path=${ctx.path}`] : []),
    `username=x-access-token`,
    `password=${result.token}`,
    `password_expiry_utc=${expiryUtc}`,
    ``,
  ];
  process.stdout.write(out.join("\n"));
}

// ============================================================================
// Entry point
// ============================================================================

async function main() {
  const args = process.argv.slice(2);

  // --token mode: bare token output for GH_TOKEN / shell wrappers
  if (args.includes("--token")) {
    const result = await getToken();
    if (result) {
      process.stdout.write(result.token);
      return;
    }
    // No config — empty stdout signals the wrapper to skip; non-zero exit
    // is an additional hint for callers that check exit codes.
    process.exit(1);
  }

  // Git credential helper actions
  const action = args[0];
  switch (action) {
    case "get":
      await handleGet();
      break;
    case "store":
      await parseStdin(); // consume stdin to avoid SIGPIPE
      break;
    case "erase":
      clearCache();
      await parseStdin();
      break;
    default:
      process.stderr.write(
        "Usage: git-credential-github-app {get|store|erase|--token}\n"
      );
      process.exit(1);
  }
}

main().catch((err) => {
  process.stderr.write(`git-credential-github-app: ${err.message}\n`);
  // Exit 0 even on error so git falls through to next credential helper
  // rather than aborting the entire operation
  process.exit(0);
});
