# -- Override the chart name
nameOverride: ""
# -- Override the full release name
fullnameOverride: ""

image:
  repository: ghcr.io/jedwards1230/openclaw-charts
  tag: latest
  pullPolicy: IfNotPresent

imagePullSecrets: []

replicaCount: 1

strategy:
  type: Recreate

# -- OpenClaw gateway configuration (templated into openclaw.json)
gateway:
  port: 18789
  bind: "lan"
  auth:
    mode: "token"
    # -- Allow Tailscale identity-header authentication (tailscale whois)
    allowTailscale: false
    # -- Rate limiting for gateway authentication (protects against brute-force attacks on LAN/public binds)
    rateLimit: {}
    #  maxAttempts: 20
    #  windowMs: 60000
    #  lockoutMs: 300000
  controlUi:
    # -- Allow non-HTTPS auth for control UI. Set to true only for local development without TLS.
    allowInsecureAuth: false
    # -- Break-glass: disable Control UI device identity checks entirely.
    # ⚠️ SEVERE SECURITY DOWNGRADE — disables per-device pairing for the web UI.
    # Use only as a temporary recovery option when locked out. Revert immediately after.
    dangerouslyDisableDeviceAuth: false
    # -- Allowed origins for the Control UI (required when gateway.bind is non-loopback).
    # List of origin URLs that are permitted to connect to the Control UI.
    # Example: ["https://openclaw.example.com"]
    allowedOrigins: []
  # -- Trusted proxy IP addresses or CIDR ranges for X-Forwarded-For trust.
  # Required when auth.mode="trusted-proxy" with bind="loopback".
  # When running behind an ingress controller (e.g. Traefik), add the controller's
  # pod CIDR to ensure accurate client IP classification and rate-limit identity.
  # Example: ["127.0.0.1/32", "10.42.0.0/16"]
  trustedProxies: []
  # -- Custom bind host address. Only used when gateway.bind="custom".
  # Example: "192.168.1.100"
  customBindHost: ""

# -- Freeform app config (merged with gateway into openclaw.json)
# Add any top-level openclaw.json keys here (agents, channels, tools, etc.)
# These are serialized to JSON as-is — no chart update needed for config changes.
config: {}

# -- Hook transform files to mount at /home/node/.openclaw/hooks/transforms
# Map of filename -> file content. When set, creates a ConfigMap and mounts it read-only.
# Example:
#   hookTransforms:
#     github.js: |
#       export default function transform(event) {
#         // Transform GitHub webhook payload
#         return event;
#       }
hookTransforms: {}

# -- Agent utility scripts to mount at ~/.openclaw/scripts (available to all workspaces/agents)
# Map of filename -> file content. When set, creates a ConfigMap and mounts it read-only.
# Scripts are mounted read-only but remain executable (ConfigMap default mode 0644, which is readable/executable for directories).
# Example:
#   agentScripts:
#     sync-repo.sh: |
#       #!/bin/bash
#       # Fetch and sync a git repository
#       cd "$1" && git fetch origin && git pull
agentScripts: {}

# -- Extra environment variables for the main container
# Use this to inject secrets, API keys, or any additional env vars.
# Example:
#   extraEnv:
#     - name: MY_SECRET
#       valueFrom:
#         secretKeyRef:
#           name: my-secret
#           key: MY_KEY
extraEnv: []

# -- Extra environment variables from secrets/configmaps (bulk injection)
# Example:
#   extraEnvFrom:
#     - secretRef:
#         name: my-secret
#     - configMapRef:
#         name: my-config
extraEnvFrom: []

# -- Git identity for commits made by OpenClaw agents
git:
  authorName: "OpenClaw"
  authorEmail: "openclaw@example.com"
  committerName: "OpenClaw"
  committerEmail: "openclaw@example.com"
  configGlobal: "/home/node/.openclaw/.gitconfig"

# -- Node.js options
nodeOptions: "--max-old-space-size=1536"

# -- Home directory path inside the container
homePath: "/home/node"

# -- Envsubst init container image (runs as non-root, must include envsubst binary)
# SECURITY: This container receives all secret environment variables at pod startup.
# Pin to a versioned tag or digest for supply-chain safety — avoid :latest in production.
# Example digest pin: dibi/envsubst:1@sha256:<digest>
envsubst:
  image: dibi/envsubst:1

# -- Secrets configuration
secrets:
  existingSecret: ""
  onepassword:
    enabled: false
    itemPath: ""

# -- NFS persistence for openclaw workspace/config
persistence:
  size: 10Gi
  accessModes:
    - ReadWriteMany
  nfs:
    enabled: false
    server: ""
    path: ""

# -- Claude Code persistence for ~/.claude directory
# Separates Claude's session data from the main NFS share for cleaner isolation.
# Uses Longhorn (or cluster default storage class) for pod-local persistence.
claudeCode:
  persistence:
    # -- Enable dedicated PVC for ~/.claude
    enabled: true
    # -- Storage size for Claude Code data
    size: 1Gi
    # -- Storage class name (empty string uses cluster default, typically "longhorn")
    storageClassName: ""

# -- Playwright Chrome Headless Shell configuration
# Installs chrome-headless-shell via Playwright for Kubernetes container environments
# where system Chromium fails due to seccomp restrictions (blocked syscalls like
# clone3, io_uring). The headless shell is purpose-built for container/CI use.
#
# When enabled, an init container runs playwright's bundled CLI to download the
# headless shell if not already cached, then patches openclaw.json to set
# browser.executablePath automatically.
#
# SECURITY NOTE: Enabling Playwright sets browser.noSandbox=true in openclaw.json.
# Chrome's renderer sandbox is disabled because it requires privileged syscalls that
# are blocked under Kubernetes RuntimeDefault seccomp. This is a known trade-off for
# containerized headless browsers. Mitigate the risk by enabling networkPolicy to
# limit what a compromised renderer process can reach.
#
# Example (minimal):
#   playwright:
#     enabled: true
#     cache:
#       enabled: true   # highly recommended — avoids re-downloading ~280MB on restart
playwright:
  # -- Enable Playwright Chrome Headless Shell installation
  enabled: false
  # -- Path where Playwright downloads browsers (PLAYWRIGHT_BROWSERS_PATH env var)
  browsersPath: "/home/node/.cache/ms-playwright"
  # -- Persist the Playwright browser cache across pod restarts
  # Strongly recommended: the headless shell is ~280MB and slow to re-download.
  cache:
    # -- Enable a dedicated PVC for the Playwright browser cache
    enabled: false
    # -- Storage size (headless shell + ffmpeg ≈ 350MB; use 1Gi for headroom)
    size: 1Gi
    # -- Storage class name (empty string uses cluster default, typically "longhorn")
    storageClassName: ""

# -- Ingress configuration
ingress:
  enabled: false
  host: ""
  annotations: {}
  tls: []

# -- Additional ingresses for separate access rules
# Useful for exposing specific endpoints (e.g., webhooks) with different
# security settings while keeping the main UI restricted to LAN-only access.
#
# Example: Expose /hooks endpoint publicly while main UI stays LAN-only
# additionalIngresses:
#   - name: webhook
#     enabled: true
#     host: openclaw.example.com
#     path: /hooks
#     pathType: Prefix
#     annotations:
#       traefik.ingress.kubernetes.io/router.entrypoints: web,websecure
#       cert-manager.io/cluster-issuer: letsencrypt-prod
#     tls:
#       - hosts:
#           - openclaw.example.com
#         secretName: openclaw-webhook-tls
additionalIngresses: []

# -- Service configuration
service:
  type: ClusterIP
  port: 18789
  # -- Target port on the container (defaults to gateway.port if not set)
  targetPort: ""

# -- ServiceAccount configuration
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""
  # Whether to automount the service account token in the pod
  automountToken: false

# -- Resource requests and limits
resources:
  requests:
    cpu: 100m
    memory: 512Mi
  limits:
    cpu: 2000m
    memory: 2Gi

# -- Pod security context
podSecurityContext:
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

# -- Container security context
securityContext:
  allowPrivilegeEscalation: false
  # Writable paths (/tmp, ~/.cache, ~/.npm) are provided via emptyDir mounts.
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  capabilities:
    drop:
      - ALL

# -- Pod annotations (e.g., Velero backup hooks)
podAnnotations: {}

# -- Priority class name for scheduling priority
priorityClassName: ""

# -- Override default health probes (TCP socket on gateway port)
# Set per-probe config to override. Omit or set to {} to use defaults.
probes:
  startup: {}
  liveness: {}
  readiness: {}

# -- Webhookd sidecar: GitHub webhook signature verification proxy
# Receives GitHub webhook POSTs, verifies X-Hub-Signature-256 HMAC,
# and forwards to openclaw's /hooks/agent endpoint using the x-openclaw-token header.
webhookd:
  enabled: false
  image:
    repository: node
    tag: "22-alpine"
    pullPolicy: IfNotPresent
  port: 8090
  # -- Target path on openclaw gateway to forward verified webhooks to
  targetPath: "/hooks/agent"
  resources:
    requests:
      cpu: 10m
      memory: 32Mi
    limits:
      cpu: 100m
      memory: 64Mi

# -- Tailscale sidecar: expose the gateway on your tailnet
# When enabled, a Tailscale sidecar container runs alongside OpenClaw,
# providing a tailnet hostname via `tailscale serve`. The OpenClaw container
# stays on LAN binding so Traefik ingress continues working.
tailscale:
  enabled: false
  # -- Existing secret containing the Tailscale auth key
  authKeySecret: ""
  # -- Key within the secret that holds the auth key value
  authKeySecretKey: "TS_AUTHKEY"
  # -- Hostname on the tailnet (e.g., "openclaw")
  hostname: ""
  # -- Tailscale image
  image:
    repository: ghcr.io/tailscale/tailscale
    tag: "v1.82.5"
    pullPolicy: IfNotPresent
  # -- Sidecar resource limits
  resources:
    requests:
      cpu: 10m
      memory: 32Mi
    limits:
      cpu: 100m
      memory: 128Mi

# -- Additional pod labels
# Note: Pod Security Admission (PSA) labels (pod-security.kubernetes.io/*)
# must be applied to the Namespace, not individual Pods. Configure them on
# the namespace outside this chart if needed.
podLabels: {}

# -- Network policy configuration
# RECOMMENDED: Enable in production. OpenClaw can execute agent code and make
# arbitrary web requests — the network policy limits egress to known ports/CIDRs.
# When enabled, applies a NetworkPolicy that:
# - Allows inbound traffic from Traefik ingress and from any pod in the same namespace
# - Allows outbound DNS (UDP/53), HTTP (TCP/80), HTTPS (TCP/443)
# - Conditionally allows egress via toggles:
#   allowMcpProxy  - mcp-proxy pods in same namespace (TCP/8080)
#   allowOllama    - Ollama LLM service (TCP/11434)
#   allowOtel      - OTEL collector in monitoring namespace (TCP/4317, TCP/4318)
networkPolicy:
  enabled: false
  # -- Allow egress to mcp-proxy pods in the same namespace (TCP/8080).
  # Only enable for gateways that need MCP tool access.
  allowMcpProxy: false
  # -- Allow egress to Ollama LLM service (TCP/11434).
  allowOllama: false
  # -- CIDR range allowed for Ollama egress. Only used when allowOllama=true.
  # Defaults to 0.0.0.0/0 (any host on port 11434) for broad compatibility — Ollama can run
  # on a LAN box, remote host, or in-cluster and the chart cannot know your topology.
  # Restrict this to your LAN subnet (e.g. "192.168.1.0/24") for tighter egress control.
  ollamaCIDR: "0.0.0.0/0"
  # -- Discord voice channel support. Requires UDP egress to Discord voice servers
  # on dynamic ports. Only needed when channels.discord.voice is enabled.
  discord:
    voice:
      # -- Enable UDP egress for Discord voice connections
      enabled: false
      # -- CIDR range for Discord voice server egress. Default allows any destination.
      # Discord voice servers use various IPs, so broad access is typically needed.
      cidr: "0.0.0.0/0"
  # -- Allow egress to OTEL collector in the monitoring namespace (TCP/4317 gRPC, TCP/4318 HTTP).
  allowOtel: false
  allowKubeAPI: false
  kubeAPICIDR: "0.0.0.0/0"
  kubeAPIPort: 6443

# -- Extra volume mounts for the main container
# Example:
#   extraVolumeMounts:
#     - name: dev-workspace
#       mountPath: /mnt/dev
extraVolumeMounts: []

# -- Extra volumes for the pod
# Example:
#   extraVolumes:
#     - name: dev-workspace
#       persistentVolumeClaim:
#         claimName: openclaw-dev-workspace
extraVolumes: []

# -- Extra init containers (in addition to the built-in envsubst and tailscale-init)
# Example:
#   extraInitContainers:
#     - name: wait-for-db
#       image: busybox:1.36
#       command: ["sh", "-c", "until nc -z db 5432; do sleep 2; done"]
extraInitContainers: []

# -- Extra sidecar containers (in addition to the built-in tailscale and webhookd)
# Example:
#   extraContainers:
#     - name: log-forwarder
#       image: fluent/fluent-bit:3.2
extraContainers: []

# -- Git repositories to clone as plugins at pod startup.
# Each entry clones a repo into /plugins/<name> and automatically appends the path
# (or /plugins/<name>/<subdir> if subdir is set) to config.plugins.load.paths.
# The cloned volume is mounted read-only in the main container.
# Repos are re-cloned fresh on every pod restart (emptyDir volume).
#
# Fields:
#   name      (required) Unique identifier used as the clone directory name.
#             Must not contain path separators. Names must be unique within pluginRepos.
#             Note: auth token env vars are named PLUGIN_TOKEN_<NAME_UPPERCASED>, so names
#             that differ only by hyphen/underscore (e.g. my-plugin and my_plugin) will
#             collide — choose distinct names to avoid this.
#   url       (required) Git clone URL. Must use https:// for authenticated repos.
#   ref       (optional) Branch, tag, or commit-ish to clone. If omitted, the repository's
#             default branch is used — set this explicitly to avoid pulling unexpected versions.
#   subdir    (optional) Subdirectory within the repo to use as the plugin root.
#             Must not start with '/' or contain '..'.
#   auth      (optional) Token-based auth for private repos (https:// URLs only).
#     secretName  Name of the K8s secret containing the token.
#     secretKey   Key within the secret (default: GITHUB_TOKEN).
#
# Example (public repo):
#   pluginRepos:
#     - name: my-plugins
#       url: https://github.com/org/openclaw-plugins.git
#       ref: main
#
# Example (private repo with token from a K8s secret):
#   pluginRepos:
#     - name: private-plugins
#       url: https://github.com/org/private-openclaw-plugins.git
#       ref: main
#       subdir: my-plugin     # optional: subdirectory within repo to use as plugin root
#       auth:
#         secretName: openclaw-secrets   # K8s secret containing the token
#         secretKey: GITHUB_TOKEN        # key within the secret (default: GITHUB_TOKEN)
pluginRepos: []

nodeSelector:
  kubernetes.io/arch: amd64
tolerations: []
affinity: {}
topologySpreadConstraints: []
