# Checks for new upstream openclaw releases every 6 hours.
# Creates or updates a version-bump PR, posts per-version release notes,
# and triggers Claude upgrade analysis.
# Supports version stacking: if multiple releases drop before merge,
# each gets its own release-notes comment and Claude analysis on the same PR.
# Uses a stable branch name (auto/bump-openclaw) so the PR persists across versions.

name: Check Upstream Release
run-name: "Check upstream release${{ github.event_name == 'workflow_dispatch' && ' (manual)' || '' }}"

on:
  schedule:
    - cron: "0 */6 * * *" # Every 6 hours (4x daily)
  workflow_dispatch:

concurrency:
  group: check-upstream
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  id-token: write # Required by claude-code-action OIDC in the analyze job

env:
  UPSTREAM_REPO: openclaw/openclaw
  BUMP_BRANCH: auto/bump-openclaw

jobs:
  check:
    name: Check for New Release
    runs-on: ubuntu-latest
    outputs:
      needs_update: ${{ steps.compare.outputs.needs_update }}
      pr_number: ${{ steps.pr.outputs.number }}
      origin_version: ${{ steps.pr.outputs.origin_version }}
      tag: ${{ steps.upstream.outputs.tag }}
      missed_tags: ${{ steps.upstream.outputs.missed_tags }}
      already_bumped: ${{ steps.check_branch.outputs.already_bumped }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get current version
        id: current
        run: |
          VERSION=$(grep '^appVersion:' charts/openclaw/Chart.yaml \
            | awk '{print $2}' | tr -d '"')
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Current appVersion: $VERSION"

      - name: Get upstream releases newer than current
        id: upstream
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CURRENT_VERSION: ${{ steps.current.outputs.version }}
        run: |
          set -euo pipefail

          # Fetch all non-prerelease, non-draft releases (paginated, up to 100)
          ALL_RELEASES=$(gh api "repos/${{ env.UPSTREAM_REPO }}/releases" \
            --paginate --jq '[.[] | select(.prerelease == false and .draft == false)] | .[].tag_name' \
            2>/dev/null || true)

          if [ -z "$ALL_RELEASES" ]; then
            echo "Failed to fetch upstream releases — skipping"
            echo "tag=" >> "$GITHUB_OUTPUT"
            echo "version=" >> "$GITHUB_OUTPUT"
            echo "missed_tags=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Find all versions newer than current using sort -V
          # Prepend current version, sort, then take everything after it
          NEWER_TAGS=$(echo "$ALL_RELEASES" | while read -r tag; do
            ver="${tag#v}"
            # Only include tags that sort higher than current
            if [ "$(printf '%s\n%s' "$CURRENT_VERSION" "$ver" | sort -V | tail -1)" = "$ver" ] \
               && [ "$ver" != "$CURRENT_VERSION" ]; then
              echo "$tag"
            fi
          done | sort -t. -k1,1n -k2,2n -k3,3n)

          if [ -z "$NEWER_TAGS" ]; then
            echo "No newer versions found"
            echo "tag=" >> "$GITHUB_OUTPUT"
            echo "version=" >> "$GITHUB_OUTPUT"
            echo "missed_tags=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Latest = last in ascending-sorted list
          LATEST_TAG=$(echo "$NEWER_TAGS" | tail -1)
          LATEST_VERSION="${LATEST_TAG#v}"

          # Build JSON array of all missed tags (ascending order)
          MISSED_JSON=$(echo "$NEWER_TAGS" | jq -R . | jq -sc .)

          echo "tag=$LATEST_TAG" >> "$GITHUB_OUTPUT"
          echo "version=$LATEST_VERSION" >> "$GITHUB_OUTPUT"
          echo "missed_tags=$MISSED_JSON" >> "$GITHUB_OUTPUT"

          COUNT=$(echo "$NEWER_TAGS" | wc -l | tr -d ' ')
          echo "Found ${COUNT} newer version(s): $(echo "$NEWER_TAGS" | tr '\n' ' ')"

      - name: Compare versions
        id: compare
        run: |
          UPSTREAM_VERSION="${{ steps.upstream.outputs.version }}"
          if [ -z "$UPSTREAM_VERSION" ]; then
            echo "Upstream version unavailable — skipping"
            echo "needs_update=false" >> "$GITHUB_OUTPUT"
          elif [ "${{ steps.current.outputs.version }}" = "$UPSTREAM_VERSION" ]; then
            echo "Up to date — nothing to do"
            echo "needs_update=false" >> "$GITHUB_OUTPUT"
          else
            echo "New version available: ${{ steps.current.outputs.version }} → $UPSTREAM_VERSION"
            echo "needs_update=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Check if branch already bumped to this version
        if: steps.compare.outputs.needs_update == 'true'
        id: check_branch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.upstream.outputs.tag }}
          VERSION: ${{ steps.upstream.outputs.version }}
        run: |
          set -euo pipefail

          # Check if the bump branch exists and already has this version
          if git ls-remote --exit-code origin "refs/heads/${{ env.BUMP_BRANCH }}" >/dev/null 2>&1; then
            git fetch origin "${{ env.BUMP_BRANCH }}"
            BRANCH_VERSION=$(git show "origin/${{ env.BUMP_BRANCH }}:charts/openclaw/Chart.yaml" \
              | grep '^appVersion:' | awk '{print $2}' | tr -d '"')
            if [ "$BRANCH_VERSION" = "$VERSION" ]; then
              echo "Branch already bumped to ${VERSION} — skipping push"
              echo "already_bumped=true" >> "$GITHUB_OUTPUT"
            else
              echo "Branch exists at ${BRANCH_VERSION}, will update to ${VERSION}"
              echo "already_bumped=false" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "Branch does not exist — will create"
            echo "already_bumped=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Bump and push branch
        if: steps.compare.outputs.needs_update == 'true' && steps.check_branch.outputs.already_bumped != 'true'
        env:
          TAG: ${{ steps.upstream.outputs.tag }}
          VERSION: ${{ steps.upstream.outputs.version }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git checkout -B "${{ env.BUMP_BRANCH }}" origin/main
          ./scripts/bump-version.sh "$VERSION" --bump-chart
          git add -A
          git commit -m "chore: bump openclaw to ${TAG}

          Upstream release: https://github.com/${{ env.UPSTREAM_REPO }}/releases/tag/${TAG}

          Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"

          # Safe push: force-with-lease when updating existing branch, normal push for new branch
          if git rev-parse --verify "origin/${{ env.BUMP_BRANCH }}" >/dev/null 2>&1; then
            EXPECTED_SHA="$(git rev-parse --verify "origin/${{ env.BUMP_BRANCH }}")"
            git push --force-with-lease="${{ env.BUMP_BRANCH }}:${EXPECTED_SHA}" origin "${{ env.BUMP_BRANCH }}"
          else
            git push origin "${{ env.BUMP_BRANCH }}"
          fi

      - name: Create or update PR
        if: steps.compare.outputs.needs_update == 'true'
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CURRENT: ${{ steps.current.outputs.version }}
          TAG: ${{ steps.upstream.outputs.tag }}
        run: |
          set -euo pipefail

          # ── Clean up old version-specific branches (legacy) ─────
          git fetch origin --prune
          while IFS= read -r remote_branch; do
            [ -z "$remote_branch" ] && continue
            LEGACY_PR=$(gh pr list --head "$remote_branch" --state open --json number --jq '.[0].number // empty' 2>/dev/null || true)
            if [ -n "$LEGACY_PR" ]; then
              gh pr close "$LEGACY_PR" --comment "Migrated to stable branch: ${{ env.BUMP_BRANCH }}" --delete-branch 2>/dev/null || true
            else
              git push origin --delete "$remote_branch" 2>/dev/null || true
            fi
          done < <(git branch -r | grep 'origin/auto/bump-openclaw-v' | sed 's|^[[:space:]]*origin/||')

          # ── Determine origin version ────────────────────────────
          EXISTING_PR=$(gh pr list --head "${{ env.BUMP_BRANCH }}" --state open \
            --json number --jq '.[0].number // empty')

          if [ -n "$EXISTING_PR" ]; then
            # Extract origin version from existing PR description (portable sed)
            PR_BODY_TEXT=$(gh pr view "$EXISTING_PR" --json body --jq '.body')
            ORIGIN_VERSION=$(printf '%s\n' "$PR_BODY_TEXT" | sed -n 's/.*\*\*Origin\*\*: `v\([^`]*\)`.*/\1/p' | head -n1)
            if [ -z "$ORIGIN_VERSION" ]; then
              ORIGIN_VERSION="$CURRENT"
            fi
          else
            ORIGIN_VERSION="$CURRENT"
          fi

          echo "origin_version=$ORIGIN_VERSION" >> "$GITHUB_OUTPUT"

          PR_BODY="## Summary

          Automated version bump from upstream release.

          - **Origin**: \`v${ORIGIN_VERSION}\`
          - **Latest**: \`${TAG}\`
          - **Release**: https://github.com/${{ env.UPSTREAM_REPO }}/releases/tag/${TAG}

          > Created automatically by the [check-upstream](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) workflow."

          # ── Create or update PR ──────────────────────────────────
          if [ -n "$EXISTING_PR" ]; then
            echo "Updating existing PR #${EXISTING_PR}"
            gh pr edit "$EXISTING_PR" \
              --title "chore: bump openclaw v${ORIGIN_VERSION} → ${TAG}" \
              --body "$PR_BODY"
            echo "number=$EXISTING_PR" >> "$GITHUB_OUTPUT"
          else
            gh pr create \
              --title "chore: bump openclaw to ${TAG}" \
              --body "$PR_BODY" \
              --head "${{ env.BUMP_BRANCH }}" \
              --base main
            PR_NUMBER=$(gh pr list --head "${{ env.BUMP_BRANCH }}" --state open \
              --json number --jq '.[0].number // empty')
            if [ -z "$PR_NUMBER" ]; then
              echo "::error::Failed to determine PR number after creation"
              exit 1
            fi
            echo "number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          fi

      - name: Post release notes comments
        if: success() && steps.compare.outputs.needs_update == 'true' && steps.pr.outputs.number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MISSED_TAGS: ${{ steps.upstream.outputs.missed_tags }}
          PR_NUMBER: ${{ steps.pr.outputs.number }}
        run: |
          set -euo pipefail

          # Fetch existing comments once (avoid repeated API calls in loop)
          EXISTING_COMMENTS=$(gh api --paginate "repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
            | jq -r '.[].body' 2>/dev/null || true)

          # Loop through each missed tag and post release notes
          echo "$MISSED_TAGS" | jq -r '.[]' | while read -r TAG; do
            # Dedup: skip if already commented for this tag
            if echo "$EXISTING_COMMENTS" | grep -qF "### Release Notes: ${TAG}"; then
              echo "Release notes for ${TAG} already posted — skipping"
              continue
            fi

            RELEASE_NOTES=$(gh api "repos/${{ env.UPSTREAM_REPO }}/releases/tags/${TAG}" \
              --jq '.body // empty' 2>/dev/null || true)

            if [ -n "$RELEASE_NOTES" ]; then
              RELEASE_NOTES="${RELEASE_NOTES:0:10000}"
              COMMENT="### Release Notes: ${TAG}

          [View on GitHub](https://github.com/${{ env.UPSTREAM_REPO }}/releases/tag/${TAG})

          <details>
          <summary>Raw upstream release notes</summary>

          \`\`\`\`
          ${RELEASE_NOTES}
          \`\`\`\`

          </details>"
              gh pr comment "$PR_NUMBER" --body "$COMMENT"
              echo "Posted release notes for ${TAG}"
            else
              echo "No release notes found for ${TAG} — skipping"
            fi
          done

      - name: Summary
        if: always()
        env:
          NEEDS_UPDATE: ${{ steps.compare.outputs.needs_update }}
          CURRENT: ${{ steps.current.outputs.version }}
          TAG: ${{ steps.upstream.outputs.tag }}
          MISSED_TAGS: ${{ steps.upstream.outputs.missed_tags }}
          ALREADY_BUMPED: ${{ steps.check_branch.outputs.already_bumped }}
        run: |
          MISSED_COUNT=$(echo "${MISSED_TAGS:-[]}" | jq 'length' 2>/dev/null || echo 0)
          if [ "$NEEDS_UPDATE" = "true" ] && [ "$ALREADY_BUMPED" = "true" ]; then
            echo "### :white_check_mark: openclaw: branch already up to date with ${TAG}" >> "$GITHUB_STEP_SUMMARY"
          elif [ "$NEEDS_UPDATE" = "true" ]; then
            echo "### :arrow_up: openclaw: v${CURRENT} → ${TAG} (${MISSED_COUNT} version(s))" >> "$GITHUB_STEP_SUMMARY"
          elif [ "$NEEDS_UPDATE" = "false" ]; then
            echo "### :white_check_mark: openclaw: up to date (v${CURRENT})" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "### :warning: openclaw: update check did not complete" >> "$GITHUB_STEP_SUMMARY"
          fi

  analyze:
    name: Claude Upgrade Analysis
    needs: check
    if: needs.check.outputs.needs_update == 'true' && needs.check.outputs.pr_number != ''
    uses: ./.github/workflows/claude-upgrade-analysis.yml
    with:
      pr_number: ${{ needs.check.outputs.pr_number }}
      origin_version: ${{ needs.check.outputs.origin_version }}
      new_tag: ${{ needs.check.outputs.tag }}
      missed_tags: ${{ needs.check.outputs.missed_tags }}
    secrets:
      anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
