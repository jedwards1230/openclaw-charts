name: Check Upstream Release
run-name: "Check upstream release${{ github.event_name == 'workflow_dispatch' && ' (manual)' || '' }}"

on:
  schedule:
    - cron: "0 */6 * * *" # Every 6 hours (4x daily)
  workflow_dispatch:

concurrency:
  group: check-upstream
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write

env:
  UPSTREAM_REPO: openclaw/openclaw

jobs:
  check:
    name: Check for New Release
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6

      - name: Get current version
        id: current
        run: |
          VERSION=$(grep '^appVersion:' charts/openclaw/Chart.yaml \
            | awk '{print $2}' | tr -d '"')
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Current appVersion: $VERSION"

      - name: Get latest upstream release
        id: upstream
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Try authenticated first, fall back to unauthenticated curl
          RELEASE_JSON=$(gh api "repos/${{ env.UPSTREAM_REPO }}/releases/latest" 2>/dev/null \
            || curl -sf "https://api.github.com/repos/${{ env.UPSTREAM_REPO }}/releases/latest" \
            || true)
          if [ -z "$RELEASE_JSON" ] || echo "$RELEASE_JSON" | jq -e 'has("message")' >/dev/null 2>&1; then
            echo "Failed to fetch upstream release — skipping"
            echo "tag=" >> "$GITHUB_OUTPUT"
            echo "version=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          TAG=$(echo "$RELEASE_JSON" | jq -r '.tag_name')
          # Strip leading 'v'
          VERSION="${TAG#v}"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Latest upstream: $TAG ($VERSION)"

      - name: Compare versions
        id: compare
        run: |
          UPSTREAM_VERSION="${{ steps.upstream.outputs.version }}"
          if [ -z "$UPSTREAM_VERSION" ]; then
            echo "Upstream version unavailable — skipping"
            echo "needs_update=false" >> "$GITHUB_OUTPUT"
          elif [ "${{ steps.current.outputs.version }}" = "$UPSTREAM_VERSION" ]; then
            echo "Up to date — nothing to do"
            echo "needs_update=false" >> "$GITHUB_OUTPUT"
          else
            echo "New version available: ${{ steps.current.outputs.version }} → $UPSTREAM_VERSION"
            echo "needs_update=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Bump and push branch
        if: steps.compare.outputs.needs_update == 'true'
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git checkout -B "auto/bump-openclaw-${{ steps.upstream.outputs.tag }}" origin/main
          ./scripts/bump-version.sh "${{ steps.upstream.outputs.version }}" --bump-chart
          git add -A
          git commit -m "chore: bump openclaw to ${{ steps.upstream.outputs.tag }}

          Upstream release: https://github.com/${{ env.UPSTREAM_REPO }}/releases/tag/${{ steps.upstream.outputs.tag }}

          Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>"
          git push --force-with-lease origin "auto/bump-openclaw-${{ steps.upstream.outputs.tag }}"

      - name: Create or update PR
        if: steps.compare.outputs.needs_update == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CURRENT: ${{ steps.current.outputs.version }}
          TAG: ${{ steps.upstream.outputs.tag }}
        run: |
          set -euo pipefail

          BRANCH="auto/bump-openclaw-${TAG}"

          # ── Clean up merged auto-bump branches ───────────────────
          git fetch origin --prune
          for remote_branch in $(git branch -r | grep 'origin/auto/bump-openclaw-' | sed 's|origin/||'); do
            if gh pr view "$remote_branch" --json state --jq '.state' 2>/dev/null | grep -q "MERGED"; then
              git push origin --delete "$remote_branch" 2>/dev/null || true
            fi
          done

          PR_BODY="## Summary

          Automated version bump from upstream release.

          - **Current**: \`v${CURRENT}\`
          - **New**: \`${TAG}\`
          - **Release**: https://github.com/${{ env.UPSTREAM_REPO }}/releases/tag/${TAG}

          > Created automatically by the [check-upstream](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) workflow."

          # ── Create or update PR ──────────────────────────────────
          EXISTING_PR=$(gh pr list --head "$BRANCH" --state open --json number --jq '.[0].number // empty')

          if [ -n "$EXISTING_PR" ]; then
            echo "Updating existing PR #${EXISTING_PR}"
            gh pr edit "$EXISTING_PR" \
              --title "chore: bump openclaw to ${TAG}" \
              --body "$PR_BODY"
          else
            gh pr create \
              --title "chore: bump openclaw to ${TAG}" \
              --body "$PR_BODY" \
              --head "$BRANCH" \
              --base main
            EXISTING_PR=$(gh pr list --head "$BRANCH" --state open --json number --jq '.[0].number')
          fi

          # ── Close superseded PRs for older versions ──────────────
          OLD_PRS=$(gh pr list --state open --json number,headRefName \
            --jq "[.[] | select(.headRefName | startswith(\"auto/bump-openclaw-\")) | select(.headRefName != \"${BRANCH}\") | .number] | .[]")
          if [ -n "$OLD_PRS" ]; then
            for pr in $OLD_PRS; do
              echo "Closing superseded PR #${pr}"
              gh pr close "$pr" --comment "Superseded by newer version: ${TAG}" --delete-branch || true
            done
          fi

          # ── Add release notes comment (deduped) ──────────────────
          RELEASE_NOTES=$(gh api "repos/${{ env.UPSTREAM_REPO }}/releases/tags/${TAG}" \
            --jq '.body // empty' 2>/dev/null || true)

          if [ -n "$RELEASE_NOTES" ]; then
            RELEASE_NOTES="${RELEASE_NOTES:0:10000}"
            COMMENT="### Release Notes for ${TAG}

          ${RELEASE_NOTES}"
            # Only post once — prevent duplicate comments on every cron run
            ALREADY_COMMENTED=$(gh api --paginate "repos/${GITHUB_REPOSITORY}/issues/${EXISTING_PR}/comments" \
              | jq --arg v "### Release Notes for ${TAG}" '[.[] | select(.body | contains($v))] | length' \
              | awk '{s+=$1} END{print s}')
            if [ "$ALREADY_COMMENTED" = "0" ]; then
              gh pr comment "$EXISTING_PR" --body "$COMMENT"
            fi
          fi

          echo "Done: PR for openclaw ${TAG}"

      - name: Summary
        if: always()
        env:
          NEEDS_UPDATE: ${{ steps.compare.outputs.needs_update }}
          CURRENT: ${{ steps.current.outputs.version }}
          TAG: ${{ steps.upstream.outputs.tag }}
        run: |
          if [ "$NEEDS_UPDATE" = "true" ]; then
            echo "### :arrow_up: openclaw: v${CURRENT} → ${TAG}" >> "$GITHUB_STEP_SUMMARY"
          elif [ "$NEEDS_UPDATE" = "false" ]; then
            echo "### :white_check_mark: openclaw: up to date (v${CURRENT})" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "### :warning: openclaw: update check did not complete" >> "$GITHUB_STEP_SUMMARY"
          fi
